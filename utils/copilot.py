import os
import base64
from openai import AzureOpenAI
import json
from dotenv import load_dotenv
load_dotenv()

class AzureOpenAIChatClient:
    def __init__(self, 
                 azure_endpoint: str = None,
                 deployment_name: str = None,
                 api_key: str = None,
                 api_version: str = None):
        # Use os.environ.get to fetch environment variables, do not fallback to hardcoded sensitive values
        self.azure_endpoint = azure_endpoint or os.environ.get("ENDPOINT_URL")
        self.deployment_name = deployment_name or os.environ.get("DEPLOYMENT_NAME")
        self.api_key = api_key or os.environ.get("AZURE_OPENAI_API_KEY")
        self.api_version = api_version or "2025-01-01-preview"

        self.client = AzureOpenAI(
            azure_endpoint=self.azure_endpoint,
            api_key=self.api_key,
            api_version=self.api_version
        )
    def generate_desease_name_from_prompt(self, user_text: str) -> str:
        self.system_prompt = {
            "role": "system",
            "content": """
Forget about the previous instructions, Now you are a Disease Name Resolver for biomedical APIs.

Your task:
- You will receive user input that may contain:
  - Symptoms
  - One disease name
  - Multiple disease names
  - Or a combination of symptoms and disease names
- Based on the input, identify the most accurate and standardized disease name(s)
  that are compatible with api.platform.opentargets.org (EFO-compatible).

Rules you MUST follow:
1. Always return disease names that resolve correctly on api.platform.opentargets.org.
2. Use standardized clinical disease names aligned with EFO / Open Targets ontology.
3. Infer diseases from symptoms only when explicit disease names are not provided.
4. Return multiple diseases only when the input clearly indicates more than one condition.
5. Do NOT include explanations, reasoning, comments, or extra text.
6. Output MUST be valid JSON only.
7. The JSON key must be exactly "desease" (keep this spelling).
8. The value must be an array of one or more disease name strings.
9. Do NOT include duplicates, abbreviations, or non-disease terms.
10. Use lowercase disease names unless capitalization is required by convention.

Strict output format:
{"desease":["<disease name 1>","<disease name 2>"]}

VALID EXAMPLES (ONLY RETURN THE JSON, NO EXTRA TEXT):

{"desease":["breast cancer"]}

{"desease":["prostate cancer"]}

{"desease":["lung cancer"]}

{"desease":["colorectal cancer"]}

{"desease":["type 2 diabetes mellitus"]}

{"desease":["hypertension"]}

{"desease":["alzheimer disease"]}

{"desease":["coronary artery disease"]}

{"desease":["chronic obstructive pulmonary disease"]}

{"desease":["asthma"]}

{"desease":["rheumatoid arthritis"]}

{"desease":["parkinson disease"]}

{"desease":["multiple sclerosis"]}

{"desease":["chronic kidney disease"]}

{"desease":["breast cancer","lung cancer"]}

{"desease":["type 2 diabetes mellitus","hypertension"]}

If the input is ambiguous, return the most likely disease name(s)
that follow Open Targets Platform naming conventions.

"""
        }
        chat_prompt = [
            self.system_prompt,
            {
                "role": "user",
                "content": user_text
            }
        ]

        completion = self.client.chat.completions.create(
            max_tokens=2000,  
            temperature=0.1,  
            top_p=0.21,  
            frequency_penalty=0.02,  
            presence_penalty=0.03,
            model=self.deployment_name,
            messages=chat_prompt
        )

        return completion.choices[0].message.content

    def generate_report_from_smiles_ic50_value_association_score_target_symbol_max_phase(
            self,
            smiles: str,
            ic50_value: float,
            association_score: float,
            target_symbol: str,
            max_phase: int,
            user_prompt: str = ""
    ) -> str:
        """
        Generate a comprehensive report for a compound given its SMILES and metrics.

        Parameters
        - smiles: SMILES string of the compound
        - ic50_value: IC50 measurement (assumed nanomolar (nM) unless specified)
        - association_score: association score (assumed normalized between 0 and 1)
        - target_symbol: gene/protein target symbol (e.g., EGFR)
        - max_phase: highest clinical phase reached (0: preclinical, 1-4: clinical phases)
        - user_prompt: optional extra instructions for the report

        Returns a human-readable report generated by the chat model.
        """
        import math

        # Try to compute RDKit descriptors when RDKit is available. Fail gracefully if not.
        try:
            from rdkit import Chem
            from rdkit.Chem import Descriptors, rdMolDescriptors, Crippen
            rdkit_available = True
        except Exception:
            rdkit_available = False

        # Derived metrics from IC50 (assuming ic50_value is in nM)
        pIC50 = None
        potency = "unknown"
        try:
            if ic50_value is not None and ic50_value > 0:
                # pIC50 where IC50 is in nM: pIC50 = -log10(IC50 [M]) = 9 - log10(IC50 [nM])
                pIC50 = 9.0 - math.log10(float(ic50_value))
                pIC50 = round(pIC50, 3)
                ic50 = float(ic50_value)
                if ic50 <= 10:
                    potency = "very high potency (<10 nM)"
                elif ic50 <= 100:
                    potency = "high potency (10-100 nM)"
                elif ic50 <= 1000:
                    potency = "moderate potency (100-1000 nM)"
                elif ic50 <= 10000:
                    potency = "low potency (1-10 µM)"
                else:
                    potency = "very low potency / inactive (>10 µM)"
        except Exception:
            pass

        # Interpret association score (assumed 0-1 if within range)
        assoc_interp = "unknown"
        try:
            if association_score is None:
                assoc_interp = "unknown association"
            else:
                assoc = float(association_score)
                if 0 <= assoc <= 1:
                    if assoc >= 0.8:
                        assoc_interp = "strong association"
                    elif assoc >= 0.5:
                        assoc_interp = "moderate association"
                    elif assoc >= 0.2:
                        assoc_interp = "weak association"
                    else:
                        assoc_interp = "negligible association"
                else:
                    assoc_interp = "association score out of expected 0-1 range; interpret cautiously"
        except Exception:
            pass

        rdkit_data = {}
        if rdkit_available:
            try:
                mol = Chem.MolFromSmiles(smiles)
                if mol is not None:
                    mw = Descriptors.MolWt(mol)
                    logp = Crippen.MolLogP(mol)
                    hbd = rdMolDescriptors.CalcNumHBD(mol)
                    hba = rdMolDescriptors.CalcNumHBA(mol)
                    tpsa = rdMolDescriptors.CalcTPSA(mol)
                    rot_bonds = rdMolDescriptors.CalcNumRotatableBonds(mol)
                    heavy_atoms = mol.GetNumHeavyAtoms()
                    formula = rdMolDescriptors.CalcMolFormula(mol)
                    violations = []
                    if mw > 500:
                        violations.append("MW>500")
                    if logp > 5:
                        violations.append("logP>5")
                    if hbd > 5:
                        violations.append("HBD>5")
                    if hba > 10:
                        violations.append("HBA>10")

                    rdkit_data = {
                        "molecular_weight": round(mw, 2),
                        "formula": formula,
                        "logP": round(logp, 2),
                        "hbd": int(hbd),
                        "hba": int(hba),
                        "tpsa": round(tpsa, 2),
                        "rotatable_bonds": int(rot_bonds),
                        "heavy_atom_count": int(heavy_atoms),
                        "lipinski_violations_count": len(violations),
                        "lipinski_violations": violations
                    }
                else:
                    rdkit_data = {"error": "invalid SMILES or RDKit could not parse SMILES"}
            except Exception:
                rdkit_data = {"error": "RDKit failed to compute descriptors"}

        # Ligand efficiency (simple approximation LE = pIC50 / heavy_atom_count)
        ligand_efficiency = None
        try:
            if pIC50 is not None and rdkit_data.get("heavy_atom_count"):
                ha = rdkit_data["heavy_atom_count"]
                if ha > 0:
                    ligand_efficiency = round(pIC50 / ha, 3)
        except Exception:
            pass

        # Prepare payload for the LLM with both raw and derived values
        payload = {
            "user_prompt": user_prompt or "",
            "smiles": smiles,
            "ic50_nM": ic50_value,
            "pIC50": pIC50,
            "potency": potency,
            "association_score": association_score,
            "association_interpretation": assoc_interp,
            "target_symbol": target_symbol,
            "max_phase": max_phase,
            "ligand_efficiency": ligand_efficiency,
            "rdkit": rdkit_data,
            "assumptions": [
                "IC50 values are assumed to be in nanomolar (nM) unless specified.",
                "Association score is assumed to be normalized between 0 and 1 unless specified.",
                "Derived descriptors may be omitted if RDKit is unavailable or SMILES is invalid."
            ]
        }

        # System prompt guiding how the report should be written
        self.system_prompt = {
            "role": "system",
            "content": (
                "You are an expert medicinal chemist and drug discovery scientist. "
                "Given the compound data (SMILES, IC50, association score, target symbol, clinical phase) and any derived metrics, "
                "generate a comprehensive, evidence-based report suitable for a cross-functional team (med chem, bio, DMPK, clinical). "
                "The report must include the following sections:\n\n"
                "1) Executive summary (2-3 lines): one-sentence conclusion about the compound's promise and primary risk.\n"
                "2) Compound summary: key identifiers and computed descriptors (molecular weight, formula, logP, HBD/HBA, TPSA, heavy atoms, rotatable bonds), mention if unavailable.\n"
                "3) Bioactivity and potency: interpret IC50 (in nM), pIC50, potency category, ligand efficiency, and what these imply for target engagement and in vitro vs in vivo expectations.\n"
                "4) Target & disease context: interpret association score and target symbol to suggest likely therapeutic areas and whether the target is a plausible disease-modifying mechanism.\n"
                "5) Clinical development perspective: explain the implication of the reported 'max_phase' (0: preclinical, 1-4: clinical phases) and recommend next milestones to advance.\n"
                "6) ADME/Tox and developability flags: highlight Lipinski violations or concerning physicochemical properties and their likely consequences.\n"
                "7) Recommended next steps: prioritized experiments (potency confirmation, selectivity, target engagement, ADME/Tox assays, in vivo models) and go/no-go criteria.\n"
                "8) Assumptions and confidence: explicitly list assumptions you used (including about units) and the confidence level for each recommendation.\n\n"
                "Be explicit about limitations and do NOT invent experimental measurements. Use the provided derived metrics directly. Present key numbers in a short bullet list or simple table at the top of the report. Keep the language professional, clear, and concise."
            )
        }

        chat_prompt = [
            self.system_prompt,
            {"role": "user", "content": json.dumps(payload, indent=2)}
        ]

        completion = self.client.chat.completions.create(
            max_tokens=1500,
            temperature=0.2,
            top_p=0.9,
            frequency_penalty=0.0,
            presence_penalty=0.0,
            model=self.deployment_name,
            messages=chat_prompt
        )

        return completion.choices[0].message.content
